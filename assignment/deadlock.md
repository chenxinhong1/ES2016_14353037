###Lab4 DeadLock
---
latest updated: 2016-10-19<br/>

> 这次的实验是对 <b>死锁</b> 的理解，以及对死锁的实验验证，难度不大，但是要理解死锁的原理，并且要知道参数对死锁可能性的影响；<br/>
> 
> <b>死锁原理：</b><br/>
> 
> 1. 资源互斥：一个资源每次只能被一个进程使用
> 2. 请求与保持条件：一个进程因请求资源而阻塞时，对已经获得的资源保持不释放
> 3. 不强制剥夺：进程已经获得的资源，在未使用完之前，其他线程无法剥夺
> 4. 循环等待：若干进程之间形成头尾相接的循环等待资源关系
> 
> 
> <b>实验步骤：
> 
> - 编写 `lab.java` 文件，包括 `class A,B,Deadlock` 的详细信息，详情看ppt
> - 利用命令 `javac lab.java` 来编译 `java` 文件
> - 编写批处理文件 `Windows -> bat`，`Linux -> sh` 来执行多次 `Deadlock Class`，从而探索死锁的原理以及参数对死锁的影响

步骤一</b><br/>

1、参考 `PPT` 上的内容完成 `lab.java` 的编写：<br/>
&emsp;&emsp;&emsp;&emsp;![code1](http://i1.piimg.com/567571/a5006b3e987985ee.png)<br/>
&emsp;&emsp;上图是关于 `class A` 和 `class B` 的定义，可以看到在函数前有关键字 `synchronized`，<b>这个关键字保证了这一个函数在同一时刻最多只能由一个线程执行，并且这个时候其他线程对代码中的 `synchronized` 代码段的访问也将被阻塞。</b>正是因为有这个关键字，才会发生死锁的情况；<br/><br/>
&emsp;&emsp;再来看 `class Deadlock` 的代码部分：<br/>
&emsp;&emsp;&emsp;&emsp;![code2](http://p1.bqimg.com/567571/dc61dd8e07f22b25.png)
<br/>
&emsp;&emsp;上图即 `Deadlock` 的详情，有以下几点解释：<br/>

- 这里有一个 `runnable` 的类，这其实是一个会一直在后台自动运行的线程，里面有 `run` 函数，当调度到这个线程时，就会跑 `run()` 函数;
- 每次 `main` 函数是构建了一个新的 `Deadlock` 类对象，而这个类对象就会新生成一个线程(即 `t` 线程)，每次该线程被调用就会跑 `run`;
- 重点看到图中的划红线以及红框的位置，`count` 这个变量的设置其实是在设置一个忙等待的时间，在 `count` 不断 `-1` 直到小于 `0` 之后跳出循环之后再继续跑，这个也是导致死锁的其中一个条件。<br/>

2、 编写好代码之后，理解一下这份代码会造成死锁的原理，来看下图：<br/>
![img1](http://p1.bqimg.com/567571/6ffac21e1b101812.png)<br/>
&emsp;&emsp;上图是一个工作的流程图，重点来看最下面的发生死锁的地方：

- 从上面的分析已经知道，`main` 这个线程是会忙等待一段时间之后，再调用对象 `a` 的`methodA` 函数，申请 `b` 的资源；而这个忙等待，其实就是消耗了线程的时间片；
- 而对于 `t` 线程，它一直位于后台，创建了,并且 `start()` 之后就会被加入调度队列里；
- <b>设想这样的一个情况：<br/></b>
&emsp;&emsp;如果 `count` 的设置与分配给 `main` 线程的时间片大致相同，也就是刚好 `count` 的 `while` 结束后，调用 `a.methodA(b)`，然后还没执行完就时间片跑完，那这个时候线程就会被迫停止；<br/>
&emsp;&emsp;此时资源 `a` 并没有被释放，main线程也不会跑完；<br/>
&emsp;&emsp;此时 `t` 线程再被调用，`run` 函数是调用 `b.method(a)`，但是此时 `a` 在刚刚的 `main` 线程中正在执行函数，所以由于 `synchronized` 关键字，线程会被阻塞；<br/>
&emsp;&emsp;回到 `main` 线程被调用，继续 a.methodA(b) 的内容，但是此时 b 又在 t 线程中被调用，正在执行methodB函数，这就导致了它也阻塞，所以造成死锁。

<b>步骤二：</b><br/>
1、上面已经完成了代码的编写以及原理分析，来看编译运行的结果：<br/>
&emsp;&emsp;![result](http://p1.bpimg.com/567571/6cfc820cb08169e5.png)<br/>
&emsp;&emsp;上面是在 `windows` 系统下的批处理文件运行结果，批处理文件就是调用 `Deadlock` 程序 `1000` 次，可以从上图看到在运行到 `354` 次的时候不再运行，发生死锁。<br/>

2、为了探讨影响死锁发生概率的参数问题，我将java文件中的count值进行更改，下面是改成 `10000` 与 `50000` 的批处理文件结果：<br/>
&emsp;&emsp;![result1](http://p1.bpimg.com/567571/eb9daf7cb0637589.png)<br/>
&emsp;&emsp;![result2](http://p1.bpimg.com/567571/cc183e43db970992.png)<br/>

&emsp;&emsp;可以从上面两张图看出，`count` 的大小其实会有一些影响，除了 `10000` 和 `50000` 之外，其实还试过一些其他的数，但是由于没有发生死锁所以没有截图，比如 `1000` ，`100000` 等大数，可能的原因我认为是：`count` 如果太小，也就是 `main` 线程会在时间片用完之前跑完；`count` 如果太大，那还没运行到 `a` 的 `methodA` 函数，就应经被迫停下，所以没有死锁，简单来讲就是，<b>看运气</b>。

###实验感想：
1. 这次实验主要是对死锁的理解以及在这份代码中，死锁是如何发生的，理解了这一点之后，实验本身并不是很难，坑的点就是不要忘记 `java` 文件中，在 `while` 后面要有一个分号，才能是忙等待（辛酸泪......）；
2. 对 `count` 参数的设置，以及批处理文件中的 `c` 的运行次数，都可能会影响到是否能看到死锁现象，因为其实线程的调度有很大的不确定性，虽然顺序确定，但是函数运行的时间是长是短都不好说，所以死锁现象的发生完全就是一个随机现象；
3. 关于 `count`，有趣的现象是，如果设置的比较小，那能看到的结果是先执行 `a.methodA(b)`；如果是比较大的 `count`，会先执行 `b.methodA(a)`，这一点跟我们之前分析的思索原因是相同的，详情可以看实验感想之前的最后一段话。

> 如有任何问题请随时联系 2461392385@qq.com